<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width,initial-scale=1.0">
<title>Cassegrain v8.4 (Zemax Export)</title>
<script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
<style>
:root{--bg:#121212;--panel:#1e1e1e;--accent:#00bcd4;--ah:#00acc1;--err:#cf6679;
      --ok:#03dac6;--warn:#ffb74d;--bdr:#333;--ibg:#2d2d2d;--sw:370px;
      --zemax:#7c4dff;--lens:#4caf50;--calc:#ff9800;--btn-opt:#e91e63;}
*,*::before,*::after{box-sizing:border-box;}
html{height:100%;}
body{font-family:'Segoe UI',Roboto,Arial,sans-serif;background:var(--bg);color:#e0e0e0;
     margin:0;padding:0;display:flex;height:100%;overflow:hidden;}
::-webkit-scrollbar{width:6px;} ::-webkit-scrollbar-thumb{background:#444;border-radius:3px;}
.sb{width:var(--sw);background:var(--panel);
    display:flex;flex-direction:column;padding:16px;overflow-y:auto;flex-shrink:0;}
.resizer-h{width:6px;background:#252525;cursor:ew-resize;flex-shrink:0;z-index:10;
           border-left:1px solid #111;border-right:1px solid #333;transition:background 0.2s;}
.resizer-v{height:6px;background:#252525;cursor:ns-resize;flex-shrink:0;z-index:10;
           border-top:1px solid #111;border-bottom:1px solid #333;transition:background 0.2s;}
.resizer-h:hover, .resizer-v:hover{background:var(--accent);}
.mc{flex:1;display:flex;flex-direction:column;background:#050505;min-width:0;overflow:hidden;}
#plotDiv{flex:1;min-height:0;}
.srow{display:grid;grid-template-columns:1fr 1fr;grid-template-rows:1fr 1fr;
      height:400px;flex-shrink:0;background:var(--bdr);gap:1px;}
.spot-chart{background:#0a0a0a;min-width:0;min-height:0;}
h1{margin:0 0 2px;font-size:1.1rem;color:var(--accent);}
.vtag{font-size:.6rem;color:#555;font-family:Consolas,monospace;margin-bottom:10px;}
h2{margin:0 0 10px;font-size:.7rem;opacity:.45;font-weight:normal;text-transform:uppercase;}
.sh{font-size:.7rem;font-weight:700;color:#666;margin:12px 0 6px;text-transform:uppercase;
    letter-spacing:1px;border-bottom:1px solid #252525;padding-bottom:2px;}
.ig{margin-bottom:6px;}
.ig label{display:block;font-size:.7rem;margin-bottom:2px;color:#888;}
.ig input[type=number],.ig input[type=range],.ig select{width:100%;background:var(--ibg);
    border:1px solid #444;color:#fff;padding:6px 8px;border-radius:4px;
    font-family:Consolas,monospace;font-size:14px;-webkit-appearance:none; transition: all 0.3s;}
.ig input[type=number]:focus,.ig select:focus{outline:none;border-color:var(--accent);}
.ig input[type=number].calc-out{background:#1a1200;border-color:#664400;color:var(--calc); box-shadow: 0 0 8px rgba(255, 152, 0, 0.4);}
.ig input[type=range]{padding:0;height:32px;background:transparent;border:none;cursor:pointer;}
.ig input[type=range]::-webkit-slider-runnable-track{background:#444;height:4px;border-radius:2px;}
.ig input[type=range]::-webkit-slider-thumb{-webkit-appearance:none;width:18px;height:18px;
    border-radius:50%;background:var(--accent);margin-top:-7px;}
.grid2{display:grid;grid-template-columns:1fr 1fr;gap:7px;}
.grid3{display:grid;grid-template-columns:1fr 1fr 1fr;gap:5px;}
.trow{display:flex;align-items:center;gap:8px;margin-bottom:7px;}
.trow label{font-size:.73rem;color:#aaa;cursor:pointer;user-select:none;}
input[type=checkbox]{width:15px;height:15px;accent-color:var(--lens);cursor:pointer;}
.preset-bar{display:flex;gap:6px;margin-bottom:10px;}
.pb-btn{flex:1;padding:8px 4px;border:1px solid #444;background:#252525;color:#aaa;
        border-radius:4px;font-size:.73rem;font-weight:600;cursor:pointer;text-align:center;
        transition:all .15s;line-height:1.3;}
.pb-btn:hover{background:#333;color:#fff;border-color:#666;}
.pb-btn.active{background:#0d2a2a;border-color:var(--accent);color:var(--accent);}
.brow{display:flex;gap:8px;margin-top:14px;}
.runb{flex:2;padding:13px;background:var(--accent);color:#000;border:none;border-radius:5px;
      font-weight:700;font-size:.83rem;cursor:pointer;text-transform:uppercase;}
.runb:hover{background:var(--ah);}
.optb{flex:2;padding:13px;background:var(--btn-opt);color:#fff;border:none;border-radius:5px;
      font-weight:700;font-size:.83rem;cursor:pointer;text-transform:uppercase; margin-bottom:10px;}
.optb:hover{background:#d81b60;}
.zmxb{flex:1;padding:13px;background:var(--zemax);color:#fff;border:none;border-radius:5px;
      font-weight:700;font-size:.76rem;cursor:pointer;text-transform:uppercase;line-height:1.2;}
.zmxb:hover{background:#651fff;}
.zmxb:disabled{background:#333;color:#555;cursor:not-allowed;}
.rp{margin-top:14px;background:#232323;padding:12px;border-radius:5px;
    border-left:3px solid var(--accent);font-family:Consolas,monospace;font-size:.8rem;}
.mr{display:flex;justify-content:space-between;margin-bottom:3px;}
.ml{color:#666;} .mv{color:#fff;font-weight:700;}
.vg{color:var(--ok);} .vb{color:var(--err);} .vi{color:var(--accent);} .vw{color:var(--warn);}
.srh{font-size:.66rem;color:#555;text-transform:uppercase;letter-spacing:1px;
     margin:8px 0 3px;border-top:1px solid #252525;padding-top:6px;}
.stb{padding:4px 10px;background:#0d0d0d;border-top:1px solid var(--bdr);
     font-size:.68rem;color:#444;display:flex;justify-content:space-between;flex-shrink:0;}
.toast{position:fixed;bottom:18px;right:18px;z-index:9999;background:#1a3a2a;
       border:1px solid var(--ok);border-radius:5px;padding:9px 14px;font-size:.78rem;
       color:var(--ok);font-family:Consolas,monospace;opacity:0;transition:opacity .3s;}
.toast.on{opacity:1;}
.agfbox{border:1px dashed #3a5a3a;border-radius:5px;padding:9px 11px;
        background:#111a11;margin-bottom:8px;}
.agflbl{display:flex;align-items:center;gap:8px;cursor:pointer;font-size:.73rem;
        color:var(--lens);font-weight:600;}
.agfst{font-size:.68rem;color:#555;margin-top:3px;font-family:Consolas,monospace;line-height:1.4;}
.chips{display:flex;flex-wrap:wrap;gap:3px;margin-top:5px;}
.chip{background:#1a3a2a;border:1px solid #2a5a3a;border-radius:10px;padding:2px 7px;
      font-size:.63rem;color:var(--ok);font-family:Consolas,monospace;}

/* ZEMAX MODAL CSS */
.mbd{display:none;position:fixed;inset:0;background:rgba(0,0,0,.78);z-index:1000;
     align-items:center;justify-content:center;padding:14px;}
.mbd.open{display:flex;}
.mdl{background:#1a1a1a;border:1px solid var(--zemax);border-radius:7px;width:100%;
     max-width:780px;max-height:90vh;display:flex;flex-direction:column;
     box-shadow:0 8px 40px rgba(124,77,255,.3);}
.mhd{display:flex;align-items:center;justify-content:space-between;padding:13px 18px;
     border-bottom:1px solid #2a2a2a;flex-shrink:0;}
.mhd h3{margin:0;font-size:.95rem;color:var(--zemax);}
.xcls{background:none;border:none;color:#555;font-size:1.3rem;cursor:pointer;padding:0 3px;}
.xcls:hover{color:#fff;}
.si{display:flex;flex-wrap:wrap;gap:7px;padding:11px 18px;
    border-bottom:1px solid #222;background:#111;flex-shrink:0;}
.sc{background:#222;border:1px solid #2a2a2a;border-radius:18px;padding:3px 11px;
    font-size:.73rem;font-family:Consolas,monospace;}
.sc span{color:var(--accent);font-weight:700;}
.tbar{display:flex;border-bottom:1px solid #2a2a2a;flex-shrink:0;}
.tb{padding:9px 16px;background:none;border:none;border-bottom:2px solid transparent;
    color:#555;font-size:.77rem;font-weight:600;text-transform:uppercase;letter-spacing:.8px;
    cursor:pointer;margin-bottom:-1px;transition:all .15s;}
.tb.act{color:var(--zemax);border-bottom-color:var(--zemax);}
.tc{flex:1;overflow-y:auto;padding:18px;}
.tp{display:none;} .tp.act{display:block;}
.lde{font-family:Consolas,monospace;font-size:.76rem;background:#0a0a0a;border:1px solid #222;
     border-radius:4px;padding:13px;overflow-x:auto;white-space:pre;line-height:1.55;color:#bbb;}
.cbr{display:flex;justify-content:flex-end;margin-top:8px;}
.cpb{background:#222;border:1px solid #3a3a3a;color:#888;padding:5px 13px;
     border-radius:4px;font-size:.73rem;cursor:pointer;}
.cpb:hover{background:#2e2e2e;color:#fff;}
.cpb.ok{background:#0a2a1a;border-color:var(--ok);color:var(--ok);}

.stp{margin-bottom:12px;padding-bottom:12px;border-bottom:1px solid #222;}
.stp:last-child{border-bottom:none;}
.stt{font-weight:700;color:var(--accent);margin-bottom:4px;font-size:.85rem;}
.stb2{font-size:.76rem;color:#ccc;line-height:1.4;}
.pb2{margin-top:6px;padding:8px;background:#111;border-left:2px solid #555;font-family:Consolas,monospace;font-size:.7rem;color:#aaa;white-space:pre;}
.wb{margin-top:6px;padding:8px;background:#2a1111;border-left:2px solid var(--err);font-size:.73rem;color:#ff8a80;}
</style>
</head>
<body>

<div class="sb" id="sb">
<header>
  <h1>Cassegrain Optimiser</h1>
  <div class="vtag">v8.4 · Enhanced Zemax Export Modal</div>
  <h2>3D Vector Ray Trace Engine</h2>
</header>

<div class="sh">Preset Systems</div>
<div class="preset-bar">
  <div class="pb-btn active" id="pre0" onclick="loadPreset(0)">Compact RC<br><span style="font-size:.65rem;color:#aaa">Hyperbolic</span></div>
  <div class="pb-btn" id="pre1" onclick="loadPreset(1)">Long-focus<br><span style="font-size:.65rem;color:#aaa">Classic</span></div>
</div>

<div class="sh">Glass Catalogues (.AGF)</div>
<div class="agfbox">
  <label class="agflbl" for="agff">
    <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2.2" stroke-linecap="round"><path d="M21 15v4a2 2 0 01-2 2H5a2 2 0 01-2-2v-4"/><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
    Click to load Zemax .AGF files
  </label>
  <input type="file" id="agff" accept=".agf" multiple style="display:none" onchange="loadAGF(this)">
  <div class="agfst" id="agfst">No .agf loaded — 8 built‑in glasses active</div>
</div>

<div class="sh">Primary Mirror (M1)</div>
<div class="grid2">
  <div class="ig"><label>Diameter (mm)</label><input type="number" id="m1d" value="600" step="any"></div>
  <div class="ig"><label>Radius (neg, mm)</label><input type="number" id="m1r" value="-2447.7" step="any"></div>
</div>
<div class="ig"><label>Conic constant k</label><input type="number" id="m1k" value="-1.04" step="any"></div>

<div class="sh">Secondary Mirror (M2)</div>
<div class="grid2">
  <div class="ig"><label>Radius (neg, mm)</label><input type="number" id="m2r" value="-272.2" step="any"></div>
  <div class="ig"><label>Conic constant k</label><input type="number" id="m2k" value="-2.1" step="any"></div>
</div>
<div class="ig"><label>M2 distance from M1 (mm)</label><input type="number" id="d1" value="1100" step="any"></div>

<div class="sh">Fold Mirror (M3) — Toroid</div>
<div class="grid2">
  <div class="ig"><label>Dist. behind M1 (mm)</label><input type="number" id="m3b" value="100" step="any"></div>
  <div class="ig"><label>Target BFL (mm)</label><input type="number" id="bfl" value="50" step="any"></div>
</div>

<div class="sh">Multi-Element Corrector</div>
<div class="trow">
  <input type="checkbox" id="len" onchange="toggleLens()" checked>
  <label for="len">Enable separated doublet corrector</label>
</div>
<div id="lpan">
  <button class="optb" onclick="optimiseCorrectorUI()">✦ Auto-Optimise Lenses (Adam)</button>
  <div class="ig">
    <label>Position before BFL (mm)</label>
    <input type="number" id="lpos" value="40" step="any">
  </div>
  <div class="grid2">
    <div class="ig"><label>Glass 1</label><select id="g1sel"></select></div>
    <div class="ig"><label>Glass 2</label><select id="g2sel"></select></div>
  </div>
  <div class="grid2">
    <div class="ig"><label>Radius 1 (mm)</label><input type="number" id="lr1" value="150" step="any"></div>
    <div class="ig"><label>Radius 2 (mm)</label><input type="number" id="lr2" value="-150" step="any"></div>
    <div class="ig"><label>Radius 3 (mm)</label><input type="number" id="lr3" value="-80" step="any"></div>
    <div class="ig"><label>Radius 4 (mm)</label><input type="number" id="lr4" value="-250" step="any"></div>
  </div>
  <div class="grid3">
    <div class="ig"><label>CT1 (mm)</label><input type="number" id="lct1" value="8" step="any"></div>
    <div class="ig"><label>Air Gap (mm)</label><input type="number" id="lgap" value="2" step="any"></div>
    <div class="ig"><label>CT2 (mm)</label><input type="number" id="lct2" value="5" step="any"></div>
  </div>
</div>

<div class="sh">Settings</div>
<div class="grid2">
  <div class="ig"><label>Ray density</label><input type="range" id="rdn" min="3" max="25" value="7"></div>
  <div class="ig"><label>Ray extension (mm)</label><input type="range" id="rex" min="0" max="500" value="50" step="10"></div>
  <div class="ig"><label>Detector diag (mm)</label><input type="number" id="det" value="20" step="any"></div>
  <div class="ig"><label>Wavelength (nm)</label><input type="number" id="lnm" value="550" step="10"></div>
</div>

<div class="brow">
  <button class="runb" onclick="RUN()">▶ Trace Rays</button>
  <button class="zmxb" id="zb" onclick="openZ()" disabled>⟳ Zemax</button>
</div>
<div class="rp" id="res"><div style="text-align:center;color:#333;padding:8px">Ready...</div></div>
</div>

<div class="resizer-h" id="resizerH"></div>

<div class="mc">
  <div id="plotDiv"></div>
  <div class="resizer-v" id="resizerV"></div>
  <div class="srow" id="srow">
    <div id="s0" class="spot-chart"></div>
    <div id="s1" class="spot-chart"></div>
    <div id="s2" class="spot-chart"></div>
    <div id="s3" class="spot-chart"></div>
  </div>
  <div class="stb"><span id="stmsg">Ready</span><span>v8.4</span></div>
</div>

<div class="toast" id="toast"></div>

<!-- ZEMAX MODAL -->
<div class="mbd" id="zmod" onclick="bdClick(event)">
  <div class="mdl">
    <div class="mhd">
      <h3>⟳ Zemax OpticStudio Export</h3>
      <button class="xcls" onclick="closeZ()">✕</button>
    </div>
    <div class="si" id="zsi"></div>
    <div class="tbar">
      <button class="tb act" onclick="swTab('lde',this)">LDE Data</button>
      <button class="tb" onclick="swTab('set',this)">Setup Guide</button>
      <button class="tb" onclick="swTab('pit',this)">Pitfalls</button>
    </div>
    <div class="tc">
      <div class="tp act" id="tp-lde">
        <div class="lde" id="lde-t"></div>
        <div class="cbr"><button class="cpb" onclick="cpy('lde-t',this)">Copy LDE</button></div>
      </div>
      <div class="tp" id="tp-set"></div>
      <div class="tp" id="tp-pit"></div>
    </div>
  </div>
</div>

<script>
'use strict';

/* ========= RESIZER LOGIC ========= */
var isDraggingH=false, isDraggingV=false;
document.getElementById('resizerH').addEventListener('mousedown', function(e){isDraggingH=true; document.body.style.cursor='ew-resize'; e.preventDefault();});
document.getElementById('resizerV').addEventListener('mousedown', function(e){isDraggingV=true; document.body.style.cursor='ns-resize'; e.preventDefault();});
window.addEventListener('mousemove', function(e){
  if(isDraggingH){ var nw=e.clientX; if(nw<300)nw=300; if(nw>800)nw=800; document.getElementById('sb').style.width=nw+'px'; }
  if(isDraggingV){ var nh=window.innerHeight-e.clientY-25; if(nh<150)nh=150; document.getElementById('srow').style.height=nh+'px'; }
});
window.addEventListener('mouseup', function(e){
  if(isDraggingH||isDraggingV){
    isDraggingH=false; isDraggingV=false; document.body.style.cursor='default';
    ['plotDiv','s0','s1','s2','s3'].forEach(id=>{let el=document.getElementById(id); if(el&&el.data)Plotly.Plots.resize(el);});
  }
});
window.addEventListener('resize', function(){
    ['plotDiv','s0','s1','s2','s3'].forEach(id=>{let el=document.getElementById(id); if(el&&el.data)Plotly.Plots.resize(el);});
});

/* ========= PRESETS ========= */
var PRESETS = [
  {m1d:600,m1r:-2447.7,m1k:-1.04, m2r:-272.2, m2k:-2.1, d1:1100,m3b:100,bfl:50, det:20, lpos:40},
  {m1d:600,m1r:-2447.7,m1k:-1.0,  m2r:-1090.5,m2k:-3.674, d1:850, m3b:300,bfl:690,det:10, lpos:100}
];
function loadPreset(idx){
  for(let i=0;i<2;i++) document.getElementById('pre'+i).classList.toggle('active',i===idx);
  let p=PRESETS[idx];
  sv('m1d',p.m1d);sv('m1r',p.m1r);sv('m1k',p.m1k);
  sv('m2r',p.m2r);sv('m2k',p.m2k);sv('d1',p.d1);
  sv('m3b',p.m3b);sv('bfl',p.bfl);sv('det',p.det);sv('lpos',p.lpos);
  toast('Preset '+(idx+1)+' loaded');
}
function sv(id,v){document.getElementById(id).value=v;}
function gv(id){return parseFloat(document.getElementById(id).value);}
var _tt=null;
function toast(msg){
  let t=document.getElementById('toast'); t.textContent=msg; t.classList.add('on');
  clearTimeout(_tt); _tt=setTimeout(()=>t.classList.remove('on'),2800);
}
function toggleLens(){document.getElementById('lpan').style.display=document.getElementById('len').checked?'block':'none';}

/* ========= GLASS DATABASE ========= */
var BUILTIN={
  'N-BK7':{nd:1.5168,Vd:64.17,f:1,c:[1.03961212,0.00600069867,0.231792344,0.0200179144,1.01046945,103.560653],cat:'SCHOTT'},
  'N-F2':{nd:1.6200,Vd:36.43,f:1,c:[1.34533359,0.00997743871,0.209073176,0.0470450767,0.937357162,111.886764],cat:'SCHOTT'},
  'SILICA':{nd:1.4585,Vd:67.82,f:1,c:[0.6961663,0.004679148,0.4079426,0.013512063,0.8974794,97.934],cat:'FUSED'}
};
var MATDB=Object.assign({},BUILTIN);

function loadAGF(inp){
  let files=Array.from(inp.files); if(!files.length)return;
  let done=0;
  files.forEach(f=>{
    let r=new FileReader();
    r.onload=e=>{
      parseAGF(e.target.result,f.name); done++;
      if(done===files.length){
        rebuildSels();
        document.getElementById('agfst').textContent=Object.keys(MATDB).length+' glasses loaded';
        toast('AGF loaded!');
      }
    };
    r.readAsText(f);
  });
}
function parseAGF(txt,fname){
  let cat=fname.replace(/\.agf$/i,'').toUpperCase(), lines=txt.split(/\r?\n/);
  for(let i=0;i<lines.length;i++){
    let l=lines[i].trim(); if(!l.startsWith('NM '))continue;
    let p=l.split(/\s+/), name=p[1]||'', f=parseInt(p[2])||1, nd=parseFloat(p[4])||1.5, Vd=parseFloat(p[5])||50, c=[];
    for(let j=i+1;j<Math.min(i+10,lines.length);j++){
      let cl=lines[j].trim(); if(cl.startsWith('CD ')){ c=cl.split(/\s+/).slice(1).map(Number).filter(v=>!isNaN(v)); break; }
      if(cl.startsWith('NM '))break;
    }
    if(name) MATDB[name]={nd:nd,Vd:Vd,f:f,c:c,cat:cat};
  }
}
function sellmeier(lum,c){let l2=lum*lum; return Math.sqrt(1+c[0]*l2/(l2-c[1])+c[2]*l2/(l2-c[3])+c[4]*l2/(l2-c[5]));}
function getN(name,lnm){
  let m=MATDB[name]; if(!m)return 1.5;
  if(m.f===1 && m.c && m.c.length>=6) return sellmeier(lnm/1000,m.c);
  return m.nd||1.5;
}
function rebuildSels(){
  let opts=Object.keys(MATDB).sort().map(k=>`<option value="${k}">${k}</option>`).join('');
  document.getElementById('g1sel').innerHTML=opts; document.getElementById('g1sel').value='N-BK7';
  document.getElementById('g2sel').innerHTML=opts; document.getElementById('g2sel').value='N-F2';
}
window.addEventListener('DOMContentLoaded', rebuildSels);

/* ========= VECTOR MATH ========= */
function vadd(a,b){return[a[0]+b[0],a[1]+b[1],a[2]+b[2]];}
function vsub(a,b){return[a[0]-b[0],a[1]-b[1],a[2]-b[2]];}
function vmul(a,s){return[a[0]*s,a[1]*s,a[2]*s];}
function vdot(a,b){return a[0]*b[0]+a[1]*b[1]+a[2]*b[2];}
function vmag(a){return Math.sqrt(a[0]*a[0]+a[1]*a[1]+a[2]*a[2]);}
function vnrm(a){let m=vmag(a);return m<1e-15?[0,0,0]:vmul(a,1/m);}
function rat(p,k,t){return vadd(p,vmul(k,t));}
function mkRay(o,d){return{p:o,k:vnrm(d)};}

/* ========= SURFACES ========= */
function hitConic(s,ray,noAp){
  let p=vsub(ray.p,[0,0,s.z0]),k=ray.k,K=s.K,c=s.c,F=(1+K)*c;
  let A=c*(k[0]*k[0]+k[1]*k[1])+F*k[2]*k[2], B=2*c*(p[0]*k[0]+p[1]*k[1])+2*F*p[2]*k[2]-2*k[2], C=c*(p[0]*p[0]+p[1]*p[1])+F*p[2]*p[2]-2*p[2], t=null;
  if(Math.abs(A)<1e-10){ if(Math.abs(B)<1e-10)return null; t=-C/B; if(t<1e-5)return null;}
  else{
    let disc=B*B-4*A*C; if(disc<0)return null; let sq=Math.sqrt(disc), t1=(-B-sq)/(2*A), t2=(-B+sq)/(2*A);
    let cands=[t1,t2].filter(v=>v>1e-5).sort((a,b)=>a-b);
    for(let i=0;i<cands.length;i++){
      let th=rat(ray.p,ray.k,cands[i]), thl=vsub(th,[0,0,s.z0]);
      if(c===0 || c*thl[2]>=-1e-4){t=cands[i];break;}
    }
  }
  if(t===null)return null;
  let h=rat(ray.p,ray.k,t), hl=vsub(h,[0,0,s.z0]);
  if(!noAp && hl[0]*hl[0]+hl[1]*hl[1]>(s.ap/2)*(s.ap/2))return null;
  let nm=vnrm([-c*hl[0],-c*hl[1],1-(K+1)*c*hl[2]]), d2=vdot(ray.k,nm);
  return{pt:h,dir:vsub(ray.k,vmul(nm,2*d2))};
}

let INV_SQRT2=1/Math.sqrt(2);
function torGlbToLoc(zm3,p){let dz=p[2]-zm3,y=p[1];return[p[0],(y-dz)*INV_SQRT2,(y+dz)*INV_SQRT2];}
function torLocToGlbVec(v){return[v[0],(v[1]+v[2])*INV_SQRT2,(-v[1]+v[2])*INV_SQRT2];}
function hitToroid(tor,ray){
  let zm3=tor.z0, Cx=tor.Cx, Cy=tor.Cy, nplane=[0,INV_SQRT2,INV_SQRT2], dn=vdot(ray.k,nplane);
  if(Math.abs(dn)<1e-8)return null;
  let tc=vdot(vsub([0,0,zm3],ray.p),nplane)/dn; if(tc<1e-4)return null;
  let dlz=(ray.k[1]+ray.k[2])*INV_SQRT2; if(Math.abs(dlz)<1e-12)return null;
  for(let i=0;i<40;i++){
    let h=rat(ray.p,ray.k,tc), loc=torGlbToLoc(zm3,h);
    let dx=1-Cx*Cx*loc[0]*loc[0], dy=1-Cy*Cy*loc[1]*loc[1];
    let zs=(Cx*loc[0]*loc[0])/(1+Math.sqrt(Math.max(dx,0)))+(Cy*loc[1]*loc[1])/(1+Math.sqrt(Math.max(dy,0)));
    let res=loc[2]-zs; if(Math.abs(res)<1e-10)break;
    tc-=res/dlz;
  }
  if(tc<1e-4||tc>3000)return null;
  let h2=rat(ray.p,ray.k,tc), loc2=torGlbToLoc(zm3,h2), dxv=Math.max(1-Cx*Cx*loc2[0]*loc2[0],0), dyv=Math.max(1-Cy*Cy*loc2[1]*loc2[1],0);
  let dsdx=Cx*loc2[0]/Math.sqrt(Math.max(dxv,1e-15)), dsdy=Cy*loc2[1]/Math.sqrt(Math.max(dyv,1e-15));
  let nl=vnrm([-dsdx,-dsdy,1]), ng=vnrm(torLocToGlbVec(nl));
  if(vdot(ray.k,ng)>0)ng=vmul(ng,-1);
  return{pt:h2,dir:vsub(ray.k,vmul(ng,2*vdot(ray.k,ng)))};
}

function mkLS(y0,R,ap,cx,cz){return{y0:y0,c:Math.abs(R)>0.5?1/R:0,ap2:(ap/2)*(ap/2),cx:cx||0,cz:cz||0};}
function hitLens(ls,ray,n1,n2){
  if(Math.abs(ray.k[1])<1e-10)return null;
  let t=(ls.y0-ray.p[1])/ray.k[1];
  for(let i=0;i<25;i++){
    let h=rat(ray.p,ray.k,t), dx=h[0]-ls.cx, dz=h[2]-ls.cz, r2=dx*dx+dz*dz, disc=1-ls.c*ls.c*r2;
    if(disc<0)return null;
    let sg=ls.c*r2/(1+Math.sqrt(disc)), dy=h[1]-(ls.y0+sg);
    if(Math.abs(dy)<1e-9)break; t-=dy/ray.k[1];
  }
  let h2=rat(ray.p,ray.k,t), dxh=h2[0]-ls.cx, dzh=h2[2]-ls.cz, r2h=dxh*dxh+dzh*dzh;
  if(r2h>ls.ap2)return null;
  let disc2=1-ls.c*ls.c*r2h; if(disc2<=0)return null;
  let nm=vnrm([-ls.c*dxh/Math.sqrt(disc2),1,-ls.c*dzh/Math.sqrt(disc2)]);
  if(vdot(ray.k,nm)>0)nm=vmul(nm,-1);
  let nr=n1/n2, cosI=-vdot(ray.k,nm), cos2T=1-nr*nr*(1-cosI*cosI);
  if(cos2T<0)return null; // TIR
  return{pt:h2,dir:vnrm(vadd(vmul(ray.k,nr),vmul(nm,nr*cosI-Math.sqrt(cos2T))))};
}

/* N-Surface Trace Engine */
function traceCorrector(corrector, ray_in){
  let cr = ray_in;
  for(let i=0; i<corrector.surfaces.length; i++){
    let s=corrector.surfaces[i], n1=corrector.indices[i], n2=corrector.indices[i+1];
    let hit = hitLens(s, cr, n1, n2);
    if(!hit) return null;
    cr = {p: hit.pt, k: hit.dir};
  }
  return cr;
}

function pupil(N){
  let pts=[{px:0,py:0,rho:0}];
  for(let r=1;r<=N;r++){ let n=6*r; for(let i=0;i<n;i++){ let a=2*Math.PI*i/n,rho=r/N; pts.push({px:rho*Math.cos(a),py:rho*Math.sin(a),rho:rho}); } }
  return pts;
}

/* SOLVER & TRACE LOGIC */
function natFocus(m1,D1,R2,K2,d1, startZ){
  let m2b={z0:-d1,K:K2,c:1/R2,ap:D1*4}, h1=hitConic(m1,mkRay([0,D1/2,startZ],[0,0,1]),false); if(!h1)return null;
  let h2=hitConic(m2b,mkRay(h1.pt,h1.dir),false); if(!h2||Math.abs(h2.dir[1])<1e-12)return null;
  let t=-h2.pt[1]/h2.dir[1]; return{znf:h2.pt[2]+t*h2.dir[2],slope:Math.abs(h2.dir[1]/h2.dir[2])};
}

function solveTor(D1,R1,K1,R2,K2,d1,zm3,bfl){
  let startZ = Math.min(-d1 - 100, -1200), TY=-bfl, m1={z0:0,K:K1,c:1/R1,ap:D1}, nf=natFocus(m1,D1,R2,K2,d1,startZ); if(!nf)return null;
  let sod=nf.znf-zm3, P=1/bfl-1/sod, Cb=P/2, Ct=Cb*Math.SQRT2, Cs=Cb*INV_SQRT2, m2big={z0:-d1,K:K2,c:1/R2,ap:D1*4};
  function mkTor(cT,cS){return{z0:zm3,Rt:Math.abs(cT)>1e-8?1/cT:1e9,Rs:Math.abs(cS)>1e-8?1/cS:1e9,Cx:cS,Cy:cT};}
  function err(cT,cS){
    let tor=mkTor(cT,cS);
    function traceT(px,py){
      let h1=hitConic(m1,mkRay([px,py,startZ],[0,0,1]),false); if(!h1)return null;
      let h2=hitConic(m2big,mkRay(h1.pt,h1.dir),false); if(!h2)return null;
      let h3=hitToroid(tor,mkRay(h2.pt,h2.dir)); if(!h3||Math.abs(h3.dir[1])<1e-10)return null;
      return vadd(h3.pt, vmul(h3.dir, (TY-h3.pt[1])/h3.dir[1]));
    }
    let ptT=traceT(0,D1/2), ptS=traceT(D1/2,0); if(!ptT||!ptS)return null;
    return {eM:ptT[2]-zm3, eS:ptS[0]};
  }
  let step=1e-6, damp=0.8;
  for(let it=0;it<150;it++){
    let r0=err(Ct,Cs); if(!r0 || (Math.abs(r0.eM)<1e-5 && Math.abs(r0.eS)<1e-5))break;
    let rT2=err(Ct+step,Cs), rS2=err(Ct,Cs+step); if(!rT2||!rS2)break;
    let J00=(rT2.eM-r0.eM)/step, J01=(rS2.eM-r0.eM)/step, J10=(rT2.eS-r0.eS)/step, J11=(rS2.eS-r0.eS)/step, det2=J00*J11-J01*J10;
    if(Math.abs(det2)<1e-20)break;
    let dCt=(J11*r0.eM-J01*r0.eS)/det2, dCs=(-J10*r0.eM+J00*r0.eS)/det2;
    Ct -= damp*Math.max(-0.005,Math.min(0.005,dCt)); Cs -= damp*Math.max(-0.005,Math.min(0.005,dCs));
  }
  let tor=mkTor(Ct,Cs), m2d_r=0, m1_h=0, sxA=[], syA=[], fP=pupil(20);
  for(let p of fP){
    let h1=hitConic(m1,mkRay([p.px*D1/2,p.py*D1/2,startZ],[0,0,1]),false); if(!h1)continue;
    let h2=hitConic(m2big,mkRay(h1.pt,h1.dir),false); if(!h2)continue;
    let h3=hitToroid(tor,mkRay(h2.pt,h2.dir)); if(!h3)continue;
    let r2c=Math.sqrt(h2.pt[0]**2+h2.pt[1]**2); if(r2c>m2d_r)m2d_r=r2c;
    let loc=torGlbToLoc(zm3,h3.pt); sxA.push(loc[0]); syA.push(loc[1]);
    if(Math.abs(h2.dir[2])>1e-6){ let t=(0-h2.pt[2])/h2.dir[2]; if(t>0){ let pz=rat(h2.pt,h2.dir,t), rz=Math.sqrt(pz[0]**2+pz[1]**2); if(rz>m1_h)m1_h=rz; }}
  }
  let sx=sxA.length?(Math.max(...sxA)-Math.min(...sxA))/2:20, sy=syA.length?(Math.max(...syA)-Math.min(...syA))/2:20;
  
  // Calculate rigorous effective F/# tracing marginal ray
  let eff_ff = 0;
  let hx1=hitConic(m1,mkRay([0,D1/2,startZ],[0,0,1]),false);
  if(hx1){
    let hx2=hitConic(m2big,mkRay(hx1.pt,hx1.dir),false);
    if(hx2){
      let hx3=hitToroid(tor,mkRay(hx2.pt,hx2.dir));
      if(hx3 && Math.abs(hx3.dir[1])>1e-10){
        let trans=Math.sqrt(hx3.dir[0]*hx3.dir[0]+hx3.dir[2]*hx3.dir[2]);
        if(trans>1e-10) eff_ff=Math.abs(hx3.dir[1])/(2*trans);
      }
    }
  }
  let nat_ff = nf.slope>1e-10 ? 1/(2*nf.slope) : 0;
  
  return{tor:tor,m1:m1,m2:{z0:-d1,K:K2,c:1/R2,ap:m2d_r*2},m2big:m2big,m2d:m2d_r*2,m1_hole:m1_h*2,sx:sx,sy:sy,znf:nf.znf,startZ:startZ,eff_ff:eff_ff,nat_ff:nat_ff};
}

function traceFull(sol, pxn, pyn, fdeg, useNative){
  let D1=sol.D1, fa=fdeg*Math.PI/180;
  let dir = [0, Math.sin(fa), Math.cos(fa)];
  
  // Mathematical pupil mapping: Ensure off-axis ray intersects M1 vertex exactly at target zone
  let targetX = pxn * D1/2, targetY = pyn * D1/2;
  let dz = sol.startZ - 0; 
  let oX = targetX + (dir[0]/dir[2]) * dz;
  let oY = targetY + (dir[1]/dir[2]) * dz;
  let r0 = mkRay([oX, oY, sol.startZ], dir);

  let h1=hitConic(sol.m1,r0,false); if(!h1 || (h1.pt[0]**2+h1.pt[1]**2)<(sol.m1_hole/2)**2)return null;
  let h2=hitConic(sol.m2,mkRay(h1.pt,h1.dir),false); if(!h2)return null;
  
  if(useNative){
      if(Math.abs(h2.dir[2])<1e-10)return null;
      let pn=vadd(h2.pt, vmul(h2.dir, (sol.znf-h2.pt[2])/h2.dir[2])); 
      return{x:pn[0]*1e3, y:pn[1]*1e3}; // Native focal plane is transverse in X/Y
  }
  
  let h3=hitToroid(sol.tor,mkRay(h2.pt,h2.dir)); if(!h3)return null;
  let cr = {p: h3.pt, k: h3.dir};
  if(sol.corrector && sol.corrector.surfaces.length>0){
      cr = traceCorrector(sol.corrector, cr);
      if(!cr) return null; // Ray clipped or TIR
  }
  if(Math.abs(cr.k[1])<1e-10)return null;
  let fp=vadd(cr.p, vmul(cr.k, (-sol.bfl-cr.p[1])/cr.k[1]));
  return {x:fp[0]*1e3, y:fp[2]*1e3}; // Effective focal plane (M3 folded) is transverse in X/Z (mapped to X/Y for charts)
}

function makeSpot(sol, fdeg, useNative, densePupil){
  let pts=pupil(densePupil?12:4), out=[];
  for(let p of pts){ let r=traceFull(sol,p.px,p.py,fdeg,useNative); if(r)out.push({x:r.x,y:r.y,rho:p.rho}); }
  if(!out.length)return{pts:[],rms:1e9,rmax:0,n:0};
  let cx=0,cy=0; out.forEach(p=>{cx+=p.x; cy+=p.y;}); cx/=out.length; cy/=out.length;
  let rms2=0, rmax2=0;
  out.forEach(p=>{ 
      p.x -= cx; p.y -= cy; // Center spot
      let r2=p.x*p.x + p.y*p.y; 
      rms2+=r2; if(r2>rmax2)rmax2=r2; 
  });
  return{pts:out, rms:Math.sqrt(rms2/out.length), rmax:Math.sqrt(rmax2), n:out.length};
}

/* ADAM OPTIMISER */
function buildCorrector(){
  if(!document.getElementById('len').checked) return null;
  let zm3 = gv('m3b'), bfl = gv('bfl'), lpos = gv('lpos');
  let dia = 30; // approx
  let r1=gv('lr1'), r2=gv('lr2'), r3=gv('lr3'), r4=gv('lr4');
  let ct1=gv('lct1'), gap=gv('lgap'), ct2=gv('lct2');
  let lnm=gv('lnm');
  let n1=getN(document.getElementById('g1sel').value, lnm), n2=getN(document.getElementById('g2sel').value, lnm);
  
  let y1 = -(bfl - lpos);
  let y2 = y1 - ct1;
  let y3 = y2 - gap;
  let y4 = y3 - ct2;
  
  return {
    surfaces: [ mkLS(y1,r1,dia,0,zm3), mkLS(y2,r2,dia,0,zm3), mkLS(y3,r3,dia,0,zm3), mkLS(y4,r4,dia,0,zm3) ],
    indices: [1.0, n1, 1.0, n2, 1.0],
    g1: document.getElementById('g1sel').value, g2: document.getElementById('g2sel').value
  };
}

function getMerit(sol){
  let sp0 = makeSpot(sol, 0, false, false);
  let sp1 = makeSpot(sol, sol.halfFov, false, false);
  if(sp0.rms > 1e6 || sp1.rms > 1e6) return 1e9; // Ray failure fallback
  return sp0.rms + (sp1.rms * 2.0); // Weight edge field heavily
}

function optimiseCorrectorUI(){
  document.getElementById('stmsg').textContent='Running Adam Optimiser...';
  setTimeout(()=>{
    try{
        let sol = createSolObj();
        if(!sol.corrector) return;
        
        // Adam implementation parameters
        let alpha = 0.005; // Learning rate
        let beta1 = 0.9, beta2 = 0.999, epsilon = 1e-8;
        let m = [0,0,0,0], v = [0,0,0,0];
        let bestMerit = getMerit(sol);
        let bestC = sol.corrector.surfaces.map(s => s.c);
        
        for(let iter=1; iter<=100; iter++){
           let grads = [];
           // Central difference Jacobian
           for(let i=0; i<4; i++){
               sol.corrector.surfaces[i].c += 1e-6;
               let mP = getMerit(sol);
               sol.corrector.surfaces[i].c -= 2e-6;
               let mM = getMerit(sol);
               sol.corrector.surfaces[i].c += 1e-6; // Reset
               grads.push( (mP - mM)/(2e-6) );
           }
           
           for(let i=0; i<4; i++) {
               m[i] = beta1 * m[i] + (1 - beta1) * grads[i];
               v[i] = beta2 * v[i] + (1 - beta2) * (grads[i] * grads[i]);
               let mHat = m[i] / (1 - Math.pow(beta1, iter));
               let vHat = v[i] / (1 - Math.pow(beta2, iter));
               
               sol.corrector.surfaces[i].c -= alpha * mHat / (Math.sqrt(vHat) + epsilon);
               // Clamping constraints
               sol.corrector.surfaces[i].c = Math.max(-0.06, Math.min(0.06, sol.corrector.surfaces[i].c));
           }
           
           let mNew = getMerit(sol);
           if(mNew < bestMerit){
               bestMerit = mNew;
               bestC = sol.corrector.surfaces.map(s => s.c);
           }
        }
        
        // Final UI push with visual highlight
        for(let i=0; i<4; i++){
            let c = bestC[i];
            let inputField = document.getElementById('lr'+(i+1));
            inputField.value = (Math.abs(c)>1e-8 ? (1/c) : 1e9).toFixed(3);
            
            // Trigger visual flash
            inputField.classList.add('calc-out');
            setTimeout(() => inputField.classList.remove('calc-out'), 2500);
        }
        toast('Adam Optimisation complete!');
        RUN(); // Re-render
    }catch(e){ toast('Opt failed: '+e.message); }
  }, 10);
}

function createSolObj(){
  let D1=gv('m1d'), R1=gv('m1r'), K1=gv('m1k'), R2=gv('m2r'), K2=gv('m2k'), d1=gv('d1'), zm3=gv('m3b'), bfl=gv('bfl');
  let det=gv('det'), lnm=gv('lnm');
  let s=solveTor(D1,R1,K1,R2,K2,d1,zm3,bfl); if(!s)throw new Error("Geom solve failed");
  let EFL_eff = s.eff_ff*D1, halfFov = EFL_eff>0 ? Math.atan(det/(2*EFL_eff))*180/Math.PI : 0;
  let airR = 1.22*(lnm*1e-6)*s.eff_ff*1e6;
  
  let sol = Object.assign({}, s, {D1:D1,R1:R1,K1:K1,R2:R2,K2:K2,d1:d1,zm3:zm3,bfl:bfl,det:det,lnm:lnm,EFL_eff:EFL_eff,halfFov:halfFov,airR:airR});
  sol.corrector = buildCorrector();
  
  if(sol.corrector){
      // Decouple optimisation aperture from drawing aperture
      let draw_radius = Math.max(10, sol.sy * gv('lpos')/bfl * 1.5);
      sol.corrector.surfaces.forEach(s => {
          s.ap2 = 1e8; // Artificially massive to prevent valid rays failing during trace
          s.draw_ap = draw_radius;
      });
  }
  return sol;
}

var SOL=null;
function RUN(){
  document.getElementById('stmsg').textContent='Tracing...';
  setTimeout(()=>{
    try{
      let sol = createSolObj();
      sol.sp0_eff = makeSpot(sol, 0, false, true);
      sol.sp1_eff = makeSpot(sol, sol.halfFov, false, true);
      sol.sp0_nat = makeSpot(sol, 0, true, true);
      sol.sp1_nat = makeSpot(sol, sol.halfFov, true, true);
      
      SOL=sol; document.getElementById('zb').disabled=false;
      buildRes(sol); plotLayout(sol); plotSpots(sol);
      document.getElementById('stmsg').textContent='Ready';
    }catch(ex){ document.getElementById('stmsg').textContent='Error: '+ex.message; }
  }, 10);
}

/* UI OUTPUT */
function buildRes(s){
  function mr(l,v,c){return`<div class="mr"><span class="ml">${l}</span><span class="mv ${c||''}">${v}</span></div>`;}
  let c0=(s.sp0_eff.rms<s.airR)?'vg':'vb', c1=(s.sp1_eff.rms<s.airR)?'vg':'vb';
  
  let lBlock = '';
  if(s.corrector){
      lBlock = `<div class="srh">Corrector Parameters</div>`+
               mr('G1/G2', s.corrector.g1+' / '+s.corrector.g2, 'vi')+
               mr('R1/R2', gv('lr1').toFixed(3)+' / '+gv('lr2').toFixed(3))+
               mr('R3/R4', gv('lr3').toFixed(3)+' / '+gv('lr4').toFixed(3))+
               mr('CT1/Gap/CT2', gv('lct1').toFixed(2)+' / '+gv('lgap').toFixed(2)+' / '+gv('lct2').toFixed(2));
  }
  
  document.getElementById('res').innerHTML=
    `<div class="srh">System Properties</div>`+
    mr('EFL (eff)', (s.EFL_eff/1000).toFixed(3)+' m')+
    mr('Nat / Eff F#', 'f/'+s.nat_ff.toFixed(2)+' / f/'+s.eff_ff.toFixed(2), 'vi')+
    mr('FoV', (s.halfFov*2).toFixed(3)+'°')+
    `<div class="srh">Spot — On-axis (RMS)</div>`+
    mr('Eff / Nat', s.sp0_eff.rms.toFixed(2)+' / '+s.sp0_nat.rms.toFixed(2)+' µm', c0)+
    mr('Airy Disk', s.airR.toFixed(1)+' µm')+
    `<div class="srh">Spot — Edge FoV (RMS)</div>`+
    mr('Eff / Nat', s.sp1_eff.rms.toFixed(2)+' / '+s.sp1_nat.rms.toFixed(2)+' µm', c1)+
    lBlock+
    `<div class="srh">Mechanical</div>`+
    mr('M2 Ø', s.m2d.toFixed(1)+' mm')+
    mr('M1 Hole Ø', s.m1_hole.toFixed(1)+' mm')+
    mr('M3 Toroid Rt/Rs', s.tor.Rt.toFixed(2)+' / '+s.tor.Rs.toFixed(2));
}

function plotLayout(sol){
  let tr=[];
  function conicC(s,dia,col,w,hd){
    let xs=[],ys=[];
    for(let i=-60;i<=60;i++){
      let h=(dia/2)*(i/60); if(Math.abs(h)<(hd||0)/2){xs.push(null);ys.push(null);continue;}
      let r2=h*h, disc=1-(1+s.K)*s.c*s.c*r2; if(disc<0)continue;
      xs.push(s.z0+(s.c*r2)/(1+Math.sqrt(disc))); ys.push(h);
    }
    return{x:xs,y:ys,mode:'lines',line:{color:col,width:w||3},showlegend:false,hoverinfo:'skip'};
  }
  tr.push(conicC(sol.m1,sol.D1,'#00bcd4',3,sol.m1_hole));
  tr.push(conicC(sol.m2,sol.m2d,'#00bcd4',2.5,0));
  
  // Toroid approx
  let ext=sol.sy, m3z=[],m3y=[];
  for(let i=0;i<=80;i++){
    let yl=ext*(2*i/80-1), dyl=1-sol.tor.Cy**2*yl*yl; if(dyl<0)continue;
    let zl=(sol.tor.Cy*yl*yl)/(1+Math.sqrt(Math.max(dyl,0)));
    m3z.push((-yl+zl)*INV_SQRT2+sol.zm3); m3y.push((yl+zl)*INV_SQRT2);
  }
  tr.push({x:m3z,y:m3y,mode:'lines',line:{color:'#ff9800',width:3},showlegend:false});
  
  // Lenses (using decoupled draw aperture)
  if(sol.corrector){
    sol.corrector.surfaces.forEach(ls=>{
        let xs=[],ys=[], lext = ls.draw_ap || 15;
        for(let i=-40;i<=40;i++){
            let h=lext*(i/40), disc=1-ls.c*ls.c*h*h; if(disc<0)continue;
            xs.push(ls.cz+h); ys.push(ls.y0 + (ls.c*h*h)/(1+Math.sqrt(disc)));
        }
        tr.push({x:xs,y:ys,mode:'lines',line:{color:'#4caf50',width:2},showlegend:false});
    });
  }
  
  // Rays
  let ND=parseInt(document.getElementById('rdn').value)||7;
  let rx=[],ry=[];
  for(let i=0;i<ND;i++){
    let h=sol.D1/2*(2*i/(ND-1)-1);
    let r1=hitConic(sol.m1,mkRay([0,h,sol.startZ],[0,0,1]),false); if(!r1||(r1.pt[0]**2+r1.pt[1]**2)<(sol.m1_hole/2)**2)continue;
    let r2=hitConic(sol.m2,mkRay(r1.pt,r1.dir),false); if(!r2)continue; 
    let r3=hitToroid(sol.tor,mkRay(r2.pt,r2.dir)); if(!r3)continue;
    rx.push(sol.startZ, r1.pt[2], r2.pt[2], r3.pt[2]); ry.push(h, r1.pt[1], r2.pt[1], r3.pt[1]);
    
    let cr = {p:r3.pt, k:r3.dir};
    if(sol.corrector){
        for(let j=0; j<sol.corrector.surfaces.length; j++){
            let hit = hitLens(sol.corrector.surfaces[j], cr, sol.corrector.indices[j], sol.corrector.indices[j+1]);
            if(hit){ rx.push(hit.pt[2]); ry.push(hit.pt[1]); cr={p:hit.pt,k:hit.dir}; } else break;
        }
    }
    let ty=(-sol.bfl-cr.p[1])/cr.k[1];
    let pe=vadd(cr.p,vmul(cr.k,ty+50));
    rx.push(pe[2], null); ry.push(pe[1], null);
  }
  tr.push({x:rx,y:ry,mode:'lines',line:{color:'rgba(255,255,255,0.15)',width:1},showlegend:false});
  
  Plotly.newPlot('plotDiv',tr,{
    title:{text:'Y-Z Layout',font:{size:13,color:'#aaa'}}, paper_bgcolor:'#050505',plot_bgcolor:'#050505',
    xaxis:{scaleanchor:'y',scaleratio:1,gridcolor:'#181818'},yaxis:{gridcolor:'#181818'},margin:{l:40,r:10,t:30,b:30}
  },{responsive:true,displayModeBar:false,scrollZoom:true});
}

function oneSpot(div,sp,title,airR){
  if(!sp.pts || !sp.pts.length){ Plotly.newPlot(div,[],{paper_bgcolor:'#0a0a0a',plot_bgcolor:'#0a0a0a',title:{text:'No Rays (Aperture Clipped)', font:{size:10,color:'#cf6679'}}}); return; }
  
  // Custom mathematical autoscaling to ensure strictly square rendering boundary
  let cMax = Math.max(sp.rmax, airR) * 1.25; 
  let th=[]; for(let i=0;i<=40;i++)th.push(2*Math.PI*i/40);
  
  Plotly.newPlot(div,[
    {x:sp.pts.map(p=>p.x),y:sp.pts.map(p=>p.y),mode:'markers',marker:{color:sp.pts.map(p=>`hsl(${240*(1-p.rho)},85%,58%)`),size:3},showlegend:false},
    {x:th.map(t=>airR*Math.cos(t)),y:th.map(t=>airR*Math.sin(t)),mode:'lines',line:{color:'rgba(255,255,255,0.3)',dash:'dash'},showlegend:false}
  ],{
    title:{text:title,font:{size:10,color:'#aaa'}}, paper_bgcolor:'#0a0a0a',plot_bgcolor:'#0a0a0a',
    xaxis:{range:[-cMax,cMax],gridcolor:'#161616',zerolinecolor:'#333'},
    yaxis:{range:[-cMax,cMax],gridcolor:'#161616',zerolinecolor:'#333',scaleanchor:'x',scaleratio:1},
    margin:{l:30,r:10,t:25,b:25},
    annotations:[{text:'RMS: '+sp.rms.toFixed(2)+'µm',xref:'paper',yref:'paper',x:0,y:1,showarrow:false,font:{size:9,color:'#888'}}]
  },{responsive:true,displayModeBar:false,scrollZoom:true});
}

function plotSpots(s){
  oneSpot('s0',s.sp0_eff,'On-Axis Eff',s.airR); oneSpot('s1',s.sp1_eff,'Edge Eff ('+s.halfFov.toFixed(2)+'°)',s.airR);
  oneSpot('s2',s.sp0_nat,'On-Axis Nat',s.airR); oneSpot('s3',s.sp1_nat,'Edge Nat ('+s.halfFov.toFixed(2)+'°)',s.airR);
}

/* ZEMAX EXPORT */
function swTab(t, b) {
  document.querySelectorAll('.tb').forEach(el => el.classList.remove('act'));
  b.classList.add('act');
  document.querySelectorAll('.tp').forEach(el => el.classList.remove('act'));
  document.getElementById('tp-' + t).classList.add('act');
}

function openZ(){
    document.getElementById('zmod').classList.add('open');
    let s=SOL;
    
    // Header Info
    document.getElementById('zsi').innerHTML = 
        `<div class="sc">EFL <span>${(s.EFL_eff/1000).toFixed(3)}m</span></div>` +
        `<div class="sc">F/# <span>${s.eff_ff.toFixed(2)}</span></div>` +
        `<div class="sc">Wav <span>${s.lnm}nm</span></div>`;
        
    // LDE Format Generator
    let txt=`! Cassegrain Optimiser v8.4 Export\nOBJ Standard Infinity Infinity\n`;
    txt+=`1 Standard ${s.R1.toFixed(3)} ${(-s.d1).toFixed(3)} MIRROR\n   Conic ${s.K1.toFixed(4)}\n`;
    txt+=`2 Standard ${s.R2.toFixed(3)} ${(s.zm3+s.d1).toFixed(3)} MIRROR\n   Conic ${s.K2.toFixed(4)}\n`;
    txt+=`3 Coordinate Break 0 0\n   Tilt X -45.0\n`;
    txt+=`4 Toroidal ${s.tor.Rt.toFixed(4)} 0 MIRROR\n   Radius of Rotation ${s.tor.Rs.toFixed(4)}\n`;
    txt+=`5 Coordinate Break 0 0\n   Tilt X -45.0\n`;
    
    if(s.corrector){
        let lpos = gv('lpos'), ct1 = gv('lct1'), gap = gv('lgap'), ct2 = gv('lct2');
        let d_to_lens = s.bfl - lpos;
        txt+= `6 Standard Infinity ${d_to_lens.toFixed(3)}\n`;
        
        let c1 = s.corrector.surfaces[0].c, r1 = Math.abs(c1) < 1e-8 ? 'Infinity' : (1/c1).toFixed(3);
        let c2 = s.corrector.surfaces[1].c, r2 = Math.abs(c2) < 1e-8 ? 'Infinity' : (1/c2).toFixed(3);
        let c3 = s.corrector.surfaces[2].c, r3 = Math.abs(c3) < 1e-8 ? 'Infinity' : (1/c3).toFixed(3);
        let c4 = s.corrector.surfaces[3].c, r4 = Math.abs(c4) < 1e-8 ? 'Infinity' : (1/c4).toFixed(3);
        
        txt+= `7 Standard ${r1} ${ct1.toFixed(3)} ${s.corrector.g1}\n`;
        txt+= `8 Standard ${r2} ${gap.toFixed(3)}\n`;
        txt+= `9 Standard ${r3} ${ct2.toFixed(3)} ${s.corrector.g2}\n`;
        let bfl_rem = lpos - ct1 - gap - ct2;
        txt+= `10 Standard ${r4} ${bfl_rem.toFixed(3)}\n`;
        txt+= `11 Image Infinity 0`;
    } else {
        txt+= `6 Image Infinity ${s.bfl.toFixed(3)}`;
    }
    document.getElementById('lde-t').innerText=txt;
    
    // Setup Guide Generation
    let setHTML = 
        `<div class="stp"><div class="stt">1. Basic setup</div><div class="stb2">Set system aperture to Entrance Pupil Diameter = ${s.D1.toFixed(1)} mm. Add a single evaluation wavelength at ${s.lnm} nm.</div></div>` +
        `<div class="stp"><div class="stt">2. Mirrors & Conics</div><div class="stb2">Input M1 and M2 radii and thicknesses. Ensure you set the explicit Conic constants (k) in the Lens Data Editor:</div><div class="pb2">M1 k = ${s.K1.toFixed(4)}\nM2 k = ${s.K2.toFixed(4)}</div></div>` +
        `<div class="stp"><div class="stt">3. Toroidal Fold Mirror (M3)</div><div class="stb2">Set surface type to 'Toroidal'. The base radius represents the tangential radius (Rt). Expand the surface properties to input the 'Radius of Rotation' (Rs).</div><div class="pb2">Radius (Rt) = ${s.tor.Rt.toFixed(4)} mm\nRadius of Rotation (Rs) = ${s.tor.Rs.toFixed(4)} mm</div></div>`;
        
    if(s.corrector){
        setHTML += `<div class="stp"><div class="stt">4. Doublet Corrector</div><div class="stb2">Add 4 standard sequential surfaces for the doublet. You must map your materials to the exact glass catalogues used to preserve dispersion characteristics.</div><div class="pb2">Glass 1 = ${s.corrector.g1}\nGlass 2 = ${s.corrector.g2}</div></div>`;
    }
    document.getElementById('tp-set').innerHTML = setHTML;
    
    // Pitfalls Generation
    document.getElementById('tp-pit').innerHTML = 
        `<div class="stp"><div class="stt">Sign conventions</div><div class="stb2">All radii follow the standard Zemax Cartesian sign convention. The concave primary faces +Z, and therefore mandates a negative radius. Thickness after reflection changes mathematical sign.</div><div class="wb">Do not arbitrarily flip thickness signs in Zemax; follow the LDE sequence strictly to maintain global coordinate integrity.</div></div>` +
        `<div class="stp"><div class="stt">Coordinate Break Integrity</div><div class="stb2">The M3 fold mirror tilt must be exactly −45° about X with the correct Coordinate Break explicitly declared both before and after the surface.</div><div class="wb">A missing or mathematically inversed secondary coordinate break will instantly break optical continuity and skew rays outside the lens aperture.</div></div>`;
}

function closeZ(){document.getElementById('zmod').classList.remove('open');}
function bdClick(e){if(e.target===e.currentTarget)closeZ();}
function cpy(id,btn){ navigator.clipboard.writeText(document.getElementById(id).innerText); btn.textContent='Copied!'; setTimeout(()=>btn.textContent='Copy',2000); }

</script>
</body>
</html>
