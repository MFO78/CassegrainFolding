<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Vector Ray Trace: Cassegrain + Toroidal M3</title>
    <!-- Import Plotly via CDN -->
    <script src="https://cdn.plot.ly/plotly-2.27.0.min.js"></script>
    <style>
        :root {
            --bg-color: #121212;
            --panel-color: #1e1e1e;
            --text-color: #e0e0e0;
            --accent-color: #00bcd4;
            --accent-hover: #00acc1;
            --error-color: #cf6679;
            --success-color: #03dac6;
            --border-color: #333;
            --input-bg: #2d2d2d;
        }

        body {
            font-family: 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
            background-color: var(--bg-color);
            color: var(--text-color);
            margin: 0;
            padding: 0;
            display: flex;
            height: 100vh;
            overflow: hidden;
        }

        /* Scrollbar styling */
        ::-webkit-scrollbar { width: 8px; }
        ::-webkit-scrollbar-track { background: var(--bg-color); }
        ::-webkit-scrollbar-thumb { background: #444; border-radius: 4px; }
        ::-webkit-scrollbar-thumb:hover { background: #555; }

        .sidebar {
            width: 360px;
            background-color: var(--panel-color);
            border-right: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            padding: 20px;
            overflow-y: auto;
            flex-shrink: 0;
            box-shadow: 4px 0 15px rgba(0,0,0,0.5);
            z-index: 10;
        }

        .main-content {
            flex: 1;
            display: flex;
            flex-direction: column;
            background-color: #050505;
            position: relative;
        }

        h1 { margin: 0 0 5px 0; font-size: 1.2rem; color: var(--accent-color); letter-spacing: 0.5px; }
        h2 { margin: 0 0 20px 0; font-size: 0.8rem; opacity: 0.6; font-weight: normal; text-transform: uppercase; }

        .section-header {
            font-size: 0.75rem;
            font-weight: 700;
            color: #888;
            margin-top: 15px;
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 1px;
            border-bottom: 1px solid #333;
            padding-bottom: 2px;
        }

        .input-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .input-group { margin-bottom: 8px; }
        .input-group label { display: block; font-size: 0.75rem; margin-bottom: 4px; color: #aaa; }
        .input-group input {
            width: 100%;
            background-color: var(--input-bg);
            border: 1px solid #444;
            color: #fff;
            padding: 6px 8px;
            border-radius: 3px;
            font-family: 'Consolas', monospace;
            font-size: 0.9rem;
            box-sizing: border-box;
            transition: border-color 0.2s, background-color 0.2s;
        }
        .input-group input:focus { outline: none; border-color: var(--accent-color); background-color: #383838; }

        button {
            width: 100%;
            padding: 12px;
            background-color: var(--accent-color);
            color: #000;
            border: none;
            border-radius: 4px;
            font-weight: bold;
            font-size: 0.85rem;
            cursor: pointer;
            margin-top: 20px;
            text-transform: uppercase;
            letter-spacing: 1px;
            transition: all 0.2s;
            box-shadow: 0 4px 6px rgba(0,0,0,0.3);
        }
        button:hover { background-color: var(--accent-hover); transform: translateY(-1px); }
        button:active { transform: translateY(1px); }

        .results-panel {
            margin-top: 20px;
            background-color: #252525;
            padding: 15px;
            border-radius: 4px;
            border-left: 3px solid var(--accent-color);
            font-family: 'Consolas', monospace;
            font-size: 0.85rem;
        }

        .metric-row { display: flex; justify-content: space-between; margin-bottom: 5px; }
        .metric-label { color: #888; }
        .metric-val { color: #fff; font-weight: bold; }
        .val-good { color: var(--success-color); }
        .val-bad { color: var(--error-color); }
        .val-info { color: var(--accent-color); }

        #plotDiv { width: 100%; height: 100%; }

        .status-bar {
            padding: 5px 10px;
            background: #1a1a1a;
            border-top: 1px solid #333;
            font-size: 0.75rem;
            color: #666;
            display: flex;
            justify-content: space-between;
        }

        .tooltip {
            font-size: 0.7rem; color: #666; margin-top: 5px; font-style: italic;
        }
    </style>
</head>
<body>

<div class="sidebar">
    <header>
        <h1>Cassegrain Optimiser</h1>
        <h2>3D Vector Ray Trace Engine</h2>
    </header>

    <div class="section-header">Primary Mirror (M1)</div>
    <div class="input-grid">
        <div class="input-group"><label>Diameter (mm)</label><input type="number" id="m1_dia" value="600"></div>
        <div class="input-group"><label>Radius (neg)</label><input type="number" id="m1_roc" value="-2447.7"></div>
    </div>
    <div class="input-group"><label>Conic (k)</label><input type="number" id="m1_k" value="-1"></div>

    <div class="section-header">Secondary Mirror (M2)</div>
    <div class="input-grid">
        <div class="input-group"><label>Radius (neg)</label><input type="number" id="m2_roc" value="-272.2"></div>
        <div class="input-group"><label>Conic (k)</label><input type="number" id="m2_k" value="-1.4336"></div>
    </div>
    <div class="input-group"><label>Dist. from M1 (mm)</label><input type="number" id="d1" value="1100"></div>

    <div class="section-header">Fold Mirror (M3) - Toroid</div>
    <div class="input-grid">
        <div class="input-group"><label>Dist. Behind M1 (mm)</label><input type="number" id="m3_back" value="100"></div>
        <div class="input-group"><label>Target BFL (mm)</label><input type="number" id="target_bfl" value="100"></div>
    </div>

    <div class="section-header">Settings</div>
    <div class="input-grid">
        <div class="input-group">
            <label>Ray Density</label>
            <input type="range" id="ray_density" min="3" max="25" value="7" style="width:100%">
        </div>
        <div class="input-group">
            <label>Ray Extension (mm)</label>
            <input type="range" id="ray_len" min="0" max="500" value="50" step="10" style="width:100%">
        </div>
    </div>

    <button onclick="runOptimization()">Run Solver</button>

    <div class="results-panel" id="results">
        <div style="text-align:center; color:#555;">Waiting for trace...</div>
    </div>
    <div class="tooltip">
        *Effective F# sensitivity improved via local NA calculation.
    </div>
</div>

<div class="main-content">
    <div id="plotDiv"></div>
    <div class="status-bar">
        <span id="status-msg">System Ready</span>
        <span>Version 3.0 (True Toroid Geometry)</span>
    </div>
</div>

<script>
/**
 * ============================================================
 * CASSEGRAIN + TOROIDAL M3 — 3D VECTOR RAY TRACE ENGINE
 * Version 3.0 — Corrections applied 2026-02-18:
 *   [1] TiltedToroid.intersect(): sag now uses separate discriminants
 *       per axis (true toroid), replacing the shared-discriminant
 *       biconic quadric formula of v2.9.
 *   [2] TiltedToroid.intersect(): surface normal uses per-axis
 *       sqrt denominators consistent with the corrected sag.
 *   [3] solveSystem(): seed for Rs corrected from Rbase*cos(45°)
 *       to Rbase/cos(45°), matching the sagittal power relation
 *       Ps = 2 / (Rs * cos θ).
 *   [4] plotSystem(): M3 profile curve uses true toroidal sag
 *       (meridional section, y-axis only) consistent with [1].
 * ============================================================
 */

// ------------------------------------------------------------
// 3D VECTOR MATH LIBRARY
// ------------------------------------------------------------
class Vec3 {
    constructor(x, y, z) { this.x = x; this.y = y; this.z = z; }
    static zero() { return new Vec3(0, 0, 0); }

    add(v)  { return new Vec3(this.x + v.x, this.y + v.y, this.z + v.z); }
    sub(v)  { return new Vec3(this.x - v.x, this.y - v.y, this.z - v.z); }
    mul(s)  { return new Vec3(this.x * s,   this.y * s,   this.z * s);   }
    dot(v)  { return this.x * v.x + this.y * v.y + this.z * v.z; }
    cross(v) {
        return new Vec3(
            this.y * v.z - this.z * v.y,
            this.z * v.x - this.x * v.z,
            this.x * v.y - this.y * v.x
        );
    }
    mag() { return Math.sqrt(this.x*this.x + this.y*this.y + this.z*this.z); }
    normalize() {
        const m = this.mag();
        return m === 0 ? Vec3.zero() : this.mul(1 / m);
    }
}

class Ray {
    constructor(origin, dir) {
        this.p = origin;
        this.k = dir.normalize();
    }
    propagate(distance) { return this.p.add(this.k.mul(distance)); }
}

// ------------------------------------------------------------
// CONIC SURFACE (M1, M2)
// Implicit form: c(x² + y² + (1+K)z²) − 2z = 0  (vertex at origin)
// Normal: ∇f = (−cx, −cy, 1−(1+K)cz)  [inward convention]
// ------------------------------------------------------------
class ConicSurface {
    constructor(z_vertex, R, K, aperture) {
        this.z0 = z_vertex;
        this.R  = R;
        this.K  = K;
        this.ap = aperture;
        this.c  = R !== 0 ? 1 / R : 0;
    }

    intersect(ray) {
        const p = ray.p.sub(new Vec3(0, 0, this.z0));
        const k = ray.k;
        const F = (1 + this.K) * this.c;

        // Quadratic coefficients — verified correct (v2.9)
        const A = this.c * (k.x*k.x + k.y*k.y) + F * k.z*k.z;
        const B = 2*this.c*(p.x*k.x + p.y*k.y) + 2*F*p.z*k.z - 2*k.z;
        const C = this.c*(p.x*p.x + p.y*p.y) + F*p.z*p.z - 2*p.z;

        let t = 0;
        if (Math.abs(A) < 1e-9) {
            t = -C / B;
        } else {
            const disc = B*B - 4*A*C;
            if (disc < 0) return null;
            const t1 = (-B - Math.sqrt(disc)) / (2*A);
            const t2 = (-B + Math.sqrt(disc)) / (2*A);
            t = (t1 > 1e-5) ? t1 : t2;
        }

        const hit       = ray.propagate(t);
        const hit_local = hit.sub(new Vec3(0, 0, this.z0));
        const r2        = hit_local.x*hit_local.x + hit_local.y*hit_local.y;
        if (r2 > (this.ap/2)*(this.ap/2)) return null;

        // Surface normal (inward-pointing, sign-agnostic for reflection)
        const nx   = -this.c * hit_local.x;
        const ny   = -this.c * hit_local.y;
        const nz   = 1 - (this.K + 1) * this.c * hit_local.z;
        const norm = new Vec3(nx, ny, nz).normalize();

        const dot     = ray.k.dot(norm);
        const k_prime = ray.k.sub(norm.mul(2 * dot));
        return { point: hit, normal: norm, out_dir: k_prime, dist: t };
    }
}

// ------------------------------------------------------------
// TILTED TOROIDAL SURFACE (M3, tilted 45° about X-axis)
//
// True toroidal sag (separate-axis form):
//   z = Cx·x² / (1 + √(1 − Cx²x²))
//     + Cy·y² / (1 + √(1 − Cy²y²))
//
// Surface normal in local frame:
//   nx_loc = −Cx·x / √(1 − Cx²x²)
//   ny_loc = −Cy·y / √(1 − Cy²y²)
//   nz_loc = 1
//
// where Cx = 1/Rs (sagittal,  x-axis)
//       Cy = 1/Rt (tangential, y-axis, meridional)
// ------------------------------------------------------------
class TiltedToroid {
    constructor(z_center, Rt, Rs, angleDeg) {
        this.z0   = z_center;
        this.Rt   = Rt;   // tangential (meridional) radius
        this.Rs   = Rs;   // sagittal radius
        this.tilt = angleDeg * Math.PI / 180;
        this.cosT = Math.cos(this.tilt);
        this.sinT = Math.sin(this.tilt);
    }

    // Rotate point into surface-local frame (rotation by +tilt about X)
    toLocal(p) {
        const dz    = p.z - this.z0;
        const y_loc =  p.y * this.cosT - dz * this.sinT;
        const z_loc =  p.y * this.sinT + dz * this.cosT;
        return new Vec3(p.x, y_loc, z_loc);
    }

    // Rotate vector back to global frame (transpose = inverse rotation)
    toGlobalVec(v) {
        const y_g =  v.y * this.cosT + v.z * this.sinT;
        const z_g = -v.y * this.sinT + v.z * this.cosT;
        return new Vec3(v.x, y_g, z_g);
    }

    // True toroidal sag: z = sagX(x) + sagY(y)  [FIX #1]
    static toroidSag(x, y, Cx, Cy) {
        const discX = 1 - Cx*Cx*x*x;
        const discY = 1 - Cy*Cy*y*y;
        if (discX < 0 || discY < 0) return null;   // outside clear aperture
        return (Cx * x*x) / (1 + Math.sqrt(discX))
             + (Cy * y*y) / (1 + Math.sqrt(discY));
    }

    intersect(ray) {
        // Seed t from flat-plane intersection along surface normal direction
        const n_plane = new Vec3(0, this.sinT, this.cosT);
        const denom   = ray.k.dot(n_plane);
        if (Math.abs(denom) < 1e-6) return null;

        const vec_to_plane = new Vec3(0, 0, this.z0).sub(ray.p);
        let t_curr = vec_to_plane.dot(n_plane) / denom;

        const Cx = 1 / this.Rs;   // sagittal curvature  (x-axis in local frame)
        const Cy = 1 / this.Rt;   // tangential curvature (y-axis in local frame)

        // Newton–Raphson iteration: converge ray parameter onto true toroid surface
        for (let i = 0; i < 20; i++) {
            const p_try = ray.propagate(t_curr);
            const loc   = this.toLocal(p_try);

            // FIX #1: true toroidal sag with separate discriminants
            const z_surf = TiltedToroid.toroidSag(loc.x, loc.y, Cx, Cy);
            if (z_surf === null) return null;

            const delta_z = loc.z - z_surf;

            // Local ray direction (finite-difference approach, unit-safe)
            const k_loc = this.toLocal(ray.p.add(ray.k)).sub(this.toLocal(ray.p));
            if (Math.abs(k_loc.z) < 1e-12) break;
            t_curr -= delta_z / k_loc.z;
        }

        const hit = ray.propagate(t_curr);
        const loc = this.toLocal(hit);

        // FIX #2: per-axis discriminants for the surface normal
        const discX = 1 - Cx*Cx*loc.x*loc.x;
        const discY = 1 - Cy*Cy*loc.y*loc.y;
        if (discX <= 0 || discY <= 0) return null;

        //   ∂z/∂x = Cx·x / √(1−Cx²x²)  →  nx_loc = −Cx·x / √(1−Cx²x²)
        //   ∂z/∂y = Cy·y / √(1−Cy²y²)  →  ny_loc = −Cy·y / √(1−Cy²y²)
        const nx_loc = -Cx * loc.x / Math.sqrt(discX);
        const ny_loc = -Cy * loc.y / Math.sqrt(discY);
        const nz_loc = 1;

        const n_loc  = new Vec3(nx_loc, ny_loc, nz_loc).normalize();
        const n_glob = this.toGlobalVec(n_loc);

        const dot     = ray.k.dot(n_glob);
        const k_prime = ray.k.sub(n_glob.mul(2 * dot));
        return { point: hit, normal: n_glob, out_dir: k_prime, dist: t_curr };
    }
}

// ------------------------------------------------------------
// SYSTEM SOLVER
// ------------------------------------------------------------
function solveSystem() {
    const D1         = parseFloat(document.getElementById('m1_dia').value);
    const R1         = parseFloat(document.getElementById('m1_roc').value);
    const K1         = parseFloat(document.getElementById('m1_k').value);
    const R2         = parseFloat(document.getElementById('m2_roc').value);
    const K2         = parseFloat(document.getElementById('m2_k').value);
    const d1         = parseFloat(document.getElementById('d1').value);
    const d_m3_back  = parseFloat(document.getElementById('m3_back').value);
    const target_bfl = parseFloat(document.getElementById('target_bfl').value);

    const z_m1     = 0;
    const z_m2     = -d1;
    const z_m3     = d_m3_back;
    const M3_TILT  = 45;
    const TARGET_Y = -target_bfl;

    const m1 = new ConicSurface(z_m1, R1, K1, D1);
    const m2 = new ConicSurface(z_m2, R2, K2, D1 * 0.5);

    // --- 1. Native M1+M2 properties (marginal ray) ---
    const rMarg = new Ray(new Vec3(0, D1/2, -1000), new Vec3(0, 0, 1));
    const h1m   = m1.intersect(rMarg);
    const h2m   = m2.intersect(new Ray(h1m.point, h1m.out_dir));

    let starting_f = 0;
    let s_obj_dist = 1000;

    if (h2m) {
        const t_focus  = -h2m.point.y / h2m.out_dir.y;
        const z_focus  = h2m.point.z + t_focus * h2m.out_dir.z;
        const tan_u    = h2m.out_dir.y / h2m.out_dir.z;
        starting_f     = ((D1/2) / Math.abs(tan_u)) / D1;
        s_obj_dist     = z_focus - z_m3;
    }

    // --- 2. Seed radii from tilted-mirror power relations ---
    //   Tangential power:  Pt = 2·cos(θ) / Rt  →  Rt = 2·cos(θ) / P
    //   Sagittal  power:   Ps = 2 / (Rs·cos(θ)) →  Rs = 2 / (P·cos(θ))  [FIX #3]
    const P_needed = (1 / target_bfl) - (1 / s_obj_dist);
    const R_base   = 2 / P_needed;
    const cos45    = Math.cos(Math.PI / 4);
    let Rt = R_base * cos45;           // Rt = Rbase · cos(45°)
    let Rs = R_base / cos45;           // Rs = Rbase / cos(45°)  ← CORRECTED

    // --- 3. Optimisation loop (decoupled diagonal Newton) ---
    function traceErrors(test_Rt, test_Rs) {
        const surfM3 = new TiltedToroid(z_m3, test_Rt, test_Rs, M3_TILT);

        // Meridional: top & bottom marginal rays
        const rTop = new Ray(new Vec3(0,  D1/2, -1000), new Vec3(0, 0, 1));
        const h1t  = m1.intersect(rTop);
        const h2t  = m2.intersect(new Ray(h1t.point, h1t.out_dir));
        const h3t  = surfM3.intersect(new Ray(h2t.point, h2t.out_dir));

        const rBot = new Ray(new Vec3(0, -D1/2, -1000), new Vec3(0, 0, 1));
        const h1b  = m1.intersect(rBot);
        const h2b  = m2.intersect(new Ray(h1b.point, h1b.out_dir));
        const h3b  = surfM3.intersect(new Ray(h2b.point, h2b.out_dir));

        if (!h3t || !h3b) return { err: true };

        // Meridional focus Y-coordinate (ray crossing in Y–Z plane)
        // Parametrise by Y: Z = pz + m·(Y − py),  m = dZ/dY
        // → Y_cross = [(pzb − mb·pyb) − (pzt − mt·pyt)] / (mt − mb)
        const mt      = h3t.out_dir.z / h3t.out_dir.y;
        const mb      = h3b.out_dir.z / h3b.out_dir.y;
        const Y_cross = (Math.abs(mt - mb) < 1e-12)
            ? -1e6
            : ((h3b.point.z - h3b.point.y*mb) - (h3t.point.z - h3t.point.y*mt)) / (mt - mb);

        // Sagittal focus: skew ray at (x = D1/2, y = 0)
        const rSkew = new Ray(new Vec3(D1/2, 0, -1000), new Vec3(0, 0, 1));
        const h1s   = m1.intersect(rSkew);
        const h2s   = m2.intersect(new Ray(h1s.point, h1s.out_dir));
        const h3s   = surfM3.intersect(new Ray(h2s.point, h2s.out_dir));
        if (!h3s) return { err: true };

        // Find Y when sagittal ray crosses x = 0
        const t_sag      = -h3s.point.x / h3s.out_dir.x;
        const Y_sag_focus = h3s.point.y + t_sag * h3s.out_dir.y;

        // Local NA for effective F# calculation
        const tan_u_local = Math.abs(h3t.out_dir.z) / Math.abs(h3t.out_dir.y);

        return { err: false, eM: Y_cross - TARGET_Y, eS: Y_sag_focus - TARGET_Y, tan_u: tan_u_local };
    }

    // Decoupled gradient-descent Newton (diagonal Jacobian)
    const step = 0.05;
    const damp = 0.95;
    for (let i = 0; i < 60; i++) {
        const res0  = traceErrors(Rt, Rs);
        if (res0.err) break;

        const resRt = traceErrors(Rt + step, Rs);
        const dEm   = (resRt.eM - res0.eM) / step;

        const resRs = traceErrors(Rt, Rs + step);
        const dEs   = (resRs.eS - res0.eS) / step;

        if (Math.abs(dEm) > 1e-16) Rt -= damp * (res0.eM / dEm);
        if (Math.abs(dEs) > 1e-16) Rs -= damp * (res0.eS / dEs);

        if (Math.abs(res0.eM) < 1e-8 && Math.abs(res0.eS) < 1e-8) break;
    }

    const final = traceErrors(Rt, Rs);
    return {
        Rt, Rs, m1, m2, z_m3, target_bfl, D1,
        starting_f,
        final_f: (!final.err ? ((D1/2) / final.tan_u) / D1 : 0)
    };
}

// ------------------------------------------------------------
// UI RUNNER
// ------------------------------------------------------------
function runOptimization() {
    const status = document.getElementById('status-msg');
    status.innerHTML = 'Optimising...';
    status.style.color = 'var(--accent-color)';

    setTimeout(() => {
        const sol    = solveSystem();
        const panel  = document.getElementById('results');
        const r_ratio = sol.Rt / sol.Rs;
        const r_diff  = Math.abs(sol.Rt - sol.Rs);

        panel.innerHTML = `
            <div class="metric-row">
                <span class="metric-label">Native F# (M1+M2)</span>
                <span class="metric-val val-info">f/${sol.starting_f.toFixed(2)}</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Effective F#</span>
                <span class="metric-val val-info">f/${sol.final_f.toFixed(2)}</span>
            </div>
            <hr style="border:0; border-top:1px solid #333; margin:8px 0;">
            <div class="metric-row">
                <span class="metric-label">M3 Radius (Tang.)</span>
                <span class="metric-val">${sol.Rt.toFixed(2)} mm</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">M3 Radius (Sag.)</span>
                <span class="metric-val">${sol.Rs.toFixed(2)} mm</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Anamorphic Ratio</span>
                <span class="metric-val">${r_ratio.toFixed(3)}</span>
            </div>
            <div class="metric-row">
                <span class="metric-label">Delta R</span>
                <span class="metric-val ${r_diff > 100 ? 'val-bad' : 'val-good'}">${r_diff.toFixed(2)} mm</span>
            </div>
        `;

        status.innerHTML = 'Trace Complete';
        status.style.color = '#666';
        plotSystem(sol);
    }, 50);
}

// ------------------------------------------------------------
// OPTICAL LAYOUT PLOT
// ------------------------------------------------------------
function plotSystem(sol) {
    const traces = [];
    const blue   = '#00bcd4';
    const orange = '#ff9800';

    // Draw a conic mirror profile in the Y–Z plane
    function drawConic(surf, dia, color) {
        const y = [], z = [];
        for (let i = -30; i <= 30; i++) {
            const h  = (dia / 2) * (i / 30);
            const r2 = h * h;
            y.push(h);
            z.push(surf.z0 + (surf.c * r2) / (1 + Math.sqrt(1 - (1 + surf.K) * surf.c * surf.c * r2)));
        }
        return { x: z, y: y, mode: 'lines', line: { color, width: 3 }, hoverinfo: 'none' };
    }

    traces.push(drawConic(sol.m1, sol.D1,       blue));
    traces.push(drawConic(sol.m2, sol.D1 * 0.4, blue));

    // --- M3 profile curve (meridional section, y-axis only) ---
    // FIX #4: uses true toroidal sag (separate y-only term, x=0)
    //   z_loc = Cy·y² / (1 + √(1 − Cy²y²))  with  Cy = 1/Rt
    const m3_y = [], m3_z = [];
    const m3_aperture = sol.D1 * 0.3;
    const Cy   = 1 / sol.Rt;
    const cosT = Math.cos(Math.PI / 4);
    const sinT = Math.sin(Math.PI / 4);
    const nPts = 61;

    for (let i = 0; i < nPts; i++) {
        const y_loc  = m3_aperture * ((i / (nPts - 1)) - 0.5);
        const discY  = 1 - Cy*Cy*y_loc*y_loc;
        // FIX #4: true toroidal sag for meridional section (x_loc = 0 → sagX term = 0)
        const z_loc  = discY > 0 ? (Cy * y_loc*y_loc) / (1 + Math.sqrt(discY)) : 0;

        // Inverse of toLocal: local → global
        m3_y.push(y_loc * cosT + z_loc * sinT);
        m3_z.push(sol.z_m3 - y_loc * sinT + z_loc * cosT);
    }

    traces.push({
        x: m3_z, y: m3_y,
        mode: 'lines',
        line: { color: orange, width: 3 },
        name: 'M3',
        hoverinfo: 'none'
    });

    // --- Ray fan ---
    const density = parseInt(document.getElementById('ray_density').value);
    const rayExt  = parseFloat(document.getElementById('ray_len').value);
    const m3Surf  = new TiltedToroid(sol.z_m3, sol.Rt, sol.Rs, 45);
    const xr = [], yr = [];

    for (let i = 0; i < density; i++) {
        const h  = (sol.D1 / 2) * ((2 * i / (density - 1)) - 1);
        const r  = new Ray(new Vec3(0, h, -500), new Vec3(0, 0, 1));
        const h1 = sol.m1.intersect(r);                                      if (!h1) continue;
        const h2 = sol.m2.intersect(new Ray(h1.point, h1.out_dir));          if (!h2) continue;
        const h3 = m3Surf.intersect(new Ray(h2.point, h2.out_dir));          if (!h3) continue;

        // Propagate ray to target focal plane (y = −BFL) then add extension
        const tf = (-sol.target_bfl - h3.point.y) / h3.out_dir.y;
        const pe = h3.point.add(h3.out_dir.mul(tf + rayExt));

        xr.push(-200, h1.point.z, h2.point.z, h3.point.z, pe.z, null);
        yr.push(h,    h1.point.y, h2.point.y, h3.point.y, pe.y, null);
    }

    traces.push({
        x: xr, y: yr,
        mode: 'lines',
        line: { color: 'rgba(255,255,255,0.2)', width: 1 },
        showlegend: false,
        hoverinfo: 'none'
    });

    Plotly.newPlot('plotDiv', traces, {
        title:        'Optical Layout (Y–Z Plane)',
        paper_bgcolor: '#050505',
        plot_bgcolor:  '#050505',
        font:  { color: '#aaa' },
        xaxis: { title: 'Z Axis (mm)', gridcolor: '#222', zerolinecolor: '#444', scaleanchor: 'y', scaleratio: 1 },
        yaxis: { title: 'Y Axis (mm)', gridcolor: '#222', zerolinecolor: '#444' },
        margin: { l: 50, r: 20, t: 40, b: 40 },
        showlegend: false,
        dragmode: 'pan'
    }, { responsive: true, displayModeBar: true, scrollZoom: true });
}

window.onload = runOptimization;
</script>
</body>
</html>
